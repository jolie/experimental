/***************************************************************************
 *   Author: Diego Castronuovo                                             *
 *   An Xtext grammar for the programming language Jolie                   *
 ***************************************************************************/
grammar jolie.xtext.Jolie hidden(WS, ML_COMMENT, SL_COMMENT)

generate jolie "http://www.xtext.org/Jolie"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore


    Program:
	(
	constants+=Constant |
	include+=Include |
	ports+=Port |
	interface+=Interface |
	types+=Type |
	init+=Init |
	execution+=Execution |
	define+=Define |
	embedded+=Embedded )*
	
	main=Main?;
	/*
 ports+=Port*
	types+=Type*
    init+=Init*
    define+=Define*
	main=Main;   OK
*/

/****************************************Types****************************************/
Constant:
  'constants' LCURLY name+=ID ASSIGN (INT|STRING|REAL|ID) (COMMA name+=ID ASSIGN (INT|STRING|REAL|ID))*   RCURLY;
    

Execution:

   'execution' LCURLY (CONCURRENT|SEQUENTIAL) RCURLY;

Include:
    'include' importURI=STRING
     ;
     
FileName:
     name=STRING;       

Type:
	'type' name=ID COLON Native_type typedef+=Typedef?;

Typedef:
	{Typedef} LCURLY
	subtypes+=Subtypes
	RCURLY;

Subtypes:
	{Subtypes} (DOT name+=ID Cardinality? COLON native_type_sub+=Native_type_sub typedef+=Typedef*)* | {Subtypes}
	QUESTION;

Cardinality:
	QUESTION | ASTERISK | (LSQUARE INT COMMA (INT | ASTERISK) RSQUARE);

Native_type:
     
	('any' | 'int' | 'raw' | 'string' | 'void'|'undefined'|'double')?;

Native_type_sub:
	{Native_type_sub} ("any" | "int" | "real" | "string" | "void"|'undefined' |'double'| type=[Type])?;

/**********************************Types***********************************************/
Embedded:
    'embedded' LCURLY ('Java'|'Jolie'|'Javascript') COLON string+=STRING (in+=ID name+=ID)? (COMMA string+=STRING (in+=ID name+=ID)?)* RCURLY;


Define:
	'define' name=ID mainrocess=MainProcess;

Init:
	name+='init' mainrocess=MainProcess;

Main:
	name='main' mainrocess=MainProcess;
	//Il processo principale, {...} del main
MainProcess:
	{OLSyntaxNode} LCURLY parallelStatement=ParallelStatement RCURLY;

	//Il processo generale inseribile a piacimento nel codice {...},(...)
Process:
	{Process} LCURLY children+=ParallelStatement RCURLY | LPAREN children+=ParallelStatement RPAREN;

	//Un parallel contiene una o pi sequenze separate da VERT '|'
ParallelStatement:
	{ParallelStatement} (children+=SequenceStatement (VERT children+=SequenceStatement)*);

	//Un sequence contiente uno o pi basic statement separati da SEMICOLON ';'
SequenceStatement:
	{SequenceStatement} (children+=BasicStatement (SEMICOLON children+=BasicStatement)*);
	
NDChoiceStatement:
/*
      
      [linkIn(linkGuard)|inputOp1] {...}
      [inputOp2] {...}      
      
     */
	{NDChoiceStatement} (LSQUARE (('linkIn' LPAREN ID RPAREN) | (operation=[OneWayOperationSignature]|operation=[RequestResponseSignature] op=InputOrOutputOperationCall)) RSQUARE mainProcess+=MainProcess)+;
	

	//Il basicStatement,  un costrutto base, ma pu anche essere un processo (questa produzione permette la ricorsione di parallel e sequence) 
BasicStatement:
	 process=Process | //Questa  la regola che mi permette la ricorsione
	 assignStatementOrPostIncrementDecrement=AssignStatementOrPostIncrementDecrementOrInputOperation |
	
	NDChoiceStatement=NDChoiceStatement |  preIncrementDecrement=PreIncrementDecrement |
	With | Synchronized | Undef | For | If | Foreach | While | {BasicStatement} NullProcces | linkIn | linkOut | call=[Define] | 
	
	operation=[OneWayOperationSignature]|operation=[RequestResponseSignature] op=InputOrOutputOperationCall |// TODO Refactor... 
	scope=Scope | compensate=Compensate | throw=Throw | install=Install | {cH} cH | {Exit} Exit;

Is_function:

 {Is_function}  ('is_defined'|'is_string'|'is_double'|'is_int') LPAREN variablePath=VariablePath RPAREN;

Install:
    'install' LPAREN installFunction=InstallFunciton RPAREN;

Throw:
    'throw' LPAREN name+=ID (COMMA name+=ID)* RPAREN;
	
Compensate:
    'comp' name=ID mainProcess=MainProcess;	

Scope:
    'scope' LPAREN name=ID RPAREN mainProcess=MainProcess;
	
InputOrOutputOperationCall:	
	LPAREN variablePath=VariablePath? RPAREN inputOperation=InputOperation /*Use the validator here to verify oneWay/reqOP*/ |
	AT outputOperation=OutputOperation;

linkIn:
	{linkIn} 'linkIn' LPAREN name=ID RPAREN;

linkOut: 
    {linkOut} 'linkOut' LPAREN name=ID RPAREN;
    

NullProcces:
	'nullProcess';
	
cH:
   'cH';	

Exit:
   'exit';

AssignStatementOrPostIncrementDecrementOrInputOperation:
	{AssignStatementOrPostIncrementDecrement} variablePath=VariablePath rightSide=RightSide;

RightSide:
	{RightSide} ASSIGN expression=Expression | {RightSide} CHOICE | {RightSide} DECREMENT | {RightSide} POINTSTO
	variablePath=VariablePath | {RightSide} DEEPCOPYLEFT variablePath=VariablePath ;

/******************************************* BASIC STATEMENTS*********************************************/
Synchronized:
	'synchronized' LPAREN name+=ID RPAREN mainProcess+=MainProcess;

Undef:
	'undef' LPAREN variablePath=VariablePath RPAREN;

OutputOperation:
	port=[InputPortStatement]|port=[OutputPortStatement] LPAREN expression=Expression? RPAREN /*Notification Operation*/ (LPAREN (variablePath=VariablePath)? RPAREN
	/*Solicit Response operation*/
	(LSQUARE installFunction=InstallFunciton RSQUARE)?)?;

InstallFunciton:
	(name+=ID | 'this') '=>' parallelStatement+=ParallelStatement (COMMA (name+=ID | 'this') '=>' parallelStatement+=ParallelStatement)*;

/*Input operation: OneWay o ReqResp*/
InputOperation:
	{InputOperation} (LPAREN expression=Expression? RPAREN mainProcess=MainProcess)?; //line 1689 OLParser, with ? ReqResponseOperation if no ? OneWayOperation
PreIncrementDecrement:
	(CHOICE | DECREMENT) variablePath=VariablePath;

/****************************************************** LOOPS *************************************************/
If:
    'if' LPAREN condition+=Condition RPAREN ifProcess=BasicStatement ('else' elseProcess=BasicStatement|ifNasted=If)?;

For:
	'for' LPAREN parallelStatement+=ParallelStatement COMMA condition=Condition COMMA parallelStatement+=ParallelStatement
	body=Body;

Body:
	RPAREN BasicStatement;

Condition:
	NOT condition+=Condition     | LPAREN  condition+=Condition  RPAREN (('&&'|'||') condition+=Condition)?|
 {Condition}	(variablePath=VariablePath | INT | STRING|isF=Is_function) rightCondition=RightCondition? (('&&'|'||') condition+=Condition)?;

RightCondition:
	(EQUAL | LANGLE | RANGLE | MAJOR_OR_EQUAL | MINOR_OR_EQUAL | NOT_EQUAL) expression=Expression;

Foreach:
	{Foreach} 'foreach' LPAREN var1=VariablePath COLON var2=VariablePath body=Body;
	
While:
   'while' LPAREN condition+=Condition RPAREN mainProcess=MainProcess;	

/***************************************************************************************************************/

/*********************************************ESPRESSIONI ARITMETICHE*********************************************/
Expression:
	TerminalExpression ({Operation.left=current} op=(PLUS | MINUS | ASTERISK | DIVIDE) right=Expression)?;

TerminalExpression returns Expression:
	LPAREN Expression RPAREN | {IntLiteral} MINUS? value=INT | {RealLiteral} MINUS? value=REAL | {String} value=STRING |
	(CHOICE |
	DECREMENT) variablePath=VariablePath | variablePath=VariablePath (CHOICE | DECREMENT)? ;

VariablePath:
	{VariablePath} HASH? dot+=DOT? name+=ID (LSQUARE children+=Expression RSQUARE)? (((DOT (ID | 'global') (LSQUARE
	children+=Expression
	RSQUARE)?) | (DOT LPAREN children+=Expression RPAREN)))* | {VariablePath} 'global' (((DOT (ID | 'global') (LSQUARE
	children+=Expression RSQUARE)?) | (DOT LPAREN children+=Expression RPAREN)))* //Global non è un un array
;

With:
	{With} 'with' LPAREN name=VariablePath RPAREN mainrocess=MainProcess;

/******************************************************************************************************************/

/*********************************************NDChoiceStatement*********************************************/
/******************************************************************************************************************/

Interface:

 'interface' name=ID LCURLY
 
 (RequestResponseOperation+=RequestResponseOperation? & oneWayOperation+=OneWayOperation?)
 
 RCURLY ;


/********************************************InputPortStatement & OutputPortStatement*************************************************/
Port:
	(inputPortStatement+=InputPortStatement | outputPortStatement+=OutputPortStatement);

InputPortStatement:
	'inputPort' name=ID LCURLY ((location+=Location)? & (protocol+=Protocol)? & (oneWayOperation+=OneWayOperation)? &
	(RequestResponseOperation+=RequestResponseOperation)? & (redirects+=Redirects)? & (aggregates+=Aggregates)? &
	(intefaces=Interfaces)?) RCURLY;

OutputPortStatement:
	'outputPort' name=ID LCURLY ((location+=Location)? & (protocol+=Protocol)? & (oneWayOperation+=OneWayOperation)? &
	(RequestResponseOperation+=RequestResponseOperation)? & (intefaces+=Interfaces)?) RCURLY;

OneWayOperation:
	{OneWayOperation} 'OneWay' COLON name=OneWayOperationSignature;
	
RequestResponseOperation:
	{RequestResponseOperation} 'RequestResponse' COLON name=RequestResponseSignature ;
	
OneWayOperationSignature:
   {OneWayOperationSignature}  name=ID (LPAREN typeDefinition+=TypeDefinition RPAREN)? (COMMA op=OneWayOperationSignature)? ;		

RequestResponseSignature:
    {RequestResponseSignature}  name=ID (LPAREN typeDefinition+=TypeDefinition RPAREN LPAREN typeDefinition+=TypeDefinition RPAREN)? ('throws' (faults+=ThrowsClause)+)? 
    (COMMA op=RequestResponseSignature)?;

ThrowsClause:
	name+=ID (LPAREN (type=TypeDefinition) RPAREN)?;	

TypeDefinition:
	type+=[Type] | {TypeDefinition} Native_type ;

Location:
	'Location' COLON uri+=Uri;

Uri:
	{Uri} name+=ID | {Uri} STRING; //|name=STRING; //to do...

Interfaces:
	'Interfaces' COLON interface+=[Interface] (COMMA interface+=[Interface])*;
	


Protocol:
	'Protocol' COLON name+=ID protocolConfiguration=ProtocolConfiguration?;

ProtocolConfiguration:
    //Here the validator shuld permit the use of prefixed 
	mainProcess=MainProcess;

Redirects:
	'Redirects' COLON redRef=RedirectDef (COMMA redRef=RedirectDef)*; //TODO LINKING TO OutPutPortDef

RedirectDef:
    name=ID '=>' outputPortIdentifier=ID;

Aggregates:
	'Aggregates' COLON name+=ID (COMMA name+=ID)*;

/***********************************************END InpuPortStatement**********************************************************************/
terminal CONCURRENT:
    'concurrent';
    
terminal SEQUENTIAL:
    'sequential';    

terminal LCURLY:
	'{';

terminal RCURLY:
	'}';

terminal LSQUARE:
	'[';

terminal RSQUARE:
	']';

terminal SEMICOLON:
	';';

terminal COLON:
	':';

terminal PLUS:
	'+';

terminal VERT:
	'|';

terminal ASSIGN:
	'=';

terminal DOT:
	'.';

terminal LPAREN:
	'(';

terminal RPAREN:
	')';

terminal COMMA:
	',';

terminal AT:
	'@';

terminal CHOICE:
	'++';

terminal DECREMENT:
	'--';

terminal ASTERISK:
	'*';

terminal QUESTION:
	'?';

terminal DIVIDE:
	'/';

terminal POINTSTO:
	'->';

terminal DEEPCOPYLEFT:
	'<<';

terminal MINUS:
	'-';

terminal PERCENT_SIGN:
	'%';

terminal EQUAL:
	'==';

terminal LANGLE:
	'<';

terminal RANGLE:
	'>';
	
terminal HASH:
    '#';	

terminal MAJOR_OR_EQUAL:
	'>=';

terminal MINOR_OR_EQUAL:
	'<=';

terminal NOT_EQUAL:
	'!=';

terminal NOT:
	'!';

terminal REAL:
	('0'..'9')* DOT ('0'..'9')+ (('e' | 'E') ('0'..'9')+)?;

terminal ID:
	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;

terminal INT returns ecore::EInt:
	('0'..'9')+;

terminal STRING:
	'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | '"' | "'" | '\\') | !('\\' | '"'))* '"' |
	"'" ('\\' ('b' | 't' | 'n' | 'f' | 'r' | '"' | "'" | '\\') | !('\\' | "'"))* "'";

terminal ML_COMMENT:
	'/*'->'*/';

terminal SL_COMMENT:
	'//' !('\n' | '\r')* ('\r'? '\n')?;

terminal WS:
	(' ' | '\t' | '\r' | '\n')+;

terminal ANY_OTHER:
	.;