grammar jolie.xtext.Jolie with org.eclipse.xtext.common.Terminals

/***************************************************************************
 *   Author: Diego Castronuovo                                             *
 *   An Xtext grammar for the programming language Jolie                   *
 ***************************************************************************/
generate jolie "http://www.xtext.org/Jolie"

Program:


 ports+=Port* 
 
 types+=Type*
 
 main=Main
;




/****************************************Types****************************************/  

 
Type:

'type' name=ID COLON Native_type typedef+=Typedef? 

;
  
Typedef: 

  {Typedef}  LCURLY 
    
        subtypes+=Subtypes
    
    RCURLY;
  
Subtypes: 
 
  {Subtypes} (  DOT name+=ID Cardinality? COLON native_type_sub+=Native_type_sub typedef+=Typedef*)* | {Subtypes} QUESTION
  
;  
  
Cardinality:

      QUESTION|ASTERISK| (LSQUARE INT COMMA (INT|ASTERISK) RSQUARE) ;   

Native_type:

  ("int"|"real"|"string"|"void")?;    
  
 Native_type_sub:  

 {Native_type_sub} ("int"|"real"|"string"|"void"|type=[Type])?; 
  
/**********************************Types***********************************************/    

Main:
	'main' mainrocess=MainProcess;
	//Il processo principale, {...} del main
MainProcess:
	{OLSyntaxNode} LCURLY parallelStatement=ParallelStatement RCURLY;

	//Il processo generale inseribile a piacimento nel codice {...},(...)
Process:
	{Process} LCURLY children+=ParallelStatement RCURLY | LPAREN children+=ParallelStatement RPAREN;

	//Un parallel contiene una o pi sequenze separate da VERT '|'
ParallelStatement:
	{ParallelStatement} (children+=SequenceStatement (VERT children+=SequenceStatement)*);

	//Un sequence contiente uno o pi basic statement separati da SEMICOLON ';'
SequenceStatement:
	{SequenceStatement} (children+=BasicStatement (SEMICOLON children+=BasicStatement)*);

	//Il basicStatement,  un costrutto base, ma pu anche essere un processo (questa produzione permette la ricorsione di parallel e sequence) 
BasicStatement:
	{BasicStatement} process=Process | //Questa  la regola che mi permette la ricorsione
	{BasicStatement} assignStatementOrPostIncrementDecrement=AssignStatementOrPostIncrementDecrementOrInputOperation | {BasicStatement}
	NDChoiceStatement=NDChoiceStatement | {BasicStatement} preIncrementDecrement=PreIncrementDecrement|
	With;

AssignStatementOrPostIncrementDecrementOrInputOperation:
	{AssignStatementOrPostIncrementDecrement} variablePath+=VariablePath rightSide=RightSide;

RightSide:
	{RightSide} ASSIGN expression=Expression | {RightSide} CHOICE | {RightSide} DECREMENT | {RightSide} POINTSTO
	variablePath=VariablePath | {RightSide} DEEPCOPYLEFT variablePath=VariablePath | /*Operation Call*/ LPAREN variablePath=VariablePath RPAREN inputOperation=InputOperation|
	AT outputOperation=OutputOperation;
	
OutputOperation: 
   
  name+=ID LPAREN expression=Expression RPAREN /*Notification Operation*/ ( LPAREN (variablePath=VariablePath)? RPAREN /*Solicit Response operation*/
  (LSQUARE installFunction=InstallFunciton RSQUARE)? )?
;
	
InstallFunciton:

 ( name+=ID | 'this' ) '=>' process+=Process (COMMA ( name+=ID | 'this' ) '=>' process+=Process )*
;	
	
/*Input operation: OneWay o ReqResp*/
InputOperation:
	{InputOperation} (LPAREN expression=Expression RPAREN mainProcess=MainProcess)?; //line 1689 OLParser, with ? ReqResponseOperation if no ? OneWayOperation
		

PreIncrementDecrement:
	(CHOICE | DECREMENT) variablePath=VariablePath;

/*********************************************ESPRESSIONI ARITMETICHE*********************************************/
Expression:
	TerminalExpression ({Operation.left=current} op=(PLUS | MINUS | ASTERISK | DIVIDE) right=Expression)?;

TerminalExpression returns Expression:
	LPAREN Expression RPAREN | {IntLiteral} MINUS? value=INT | {RealLiteral} MINUS? value=REAL | {String} value=STRING | (CHOICE |
	DECREMENT) variablePath=VariablePath | variablePath=VariablePath (CHOICE | DECREMENT)?;

VariablePath :
    
	{VariablePath}  dot+=DOT? name+=ID (LSQUARE children+=Expression RSQUARE)? (((DOT (ID | 'global') (LSQUARE children+=Expression
	RSQUARE)?) | (DOT LPAREN children+=Expression RPAREN)))* | {VariablePath} 'global' (((DOT (ID | 'global') (LSQUARE
	children+=Expression RSQUARE)?) | (DOT LPAREN children+=Expression RPAREN)))* //Global non  un un array
;
    
With :

 {With} 'with' LPAREN name+=VariablePath RPAREN mainrocess+=MainProcess;

/******************************************************************************************************************/

/*********************************************NDChoiceStatement*********************************************/
NDChoiceStatement:
    /*
      
      [linkIn(linkGuard)|inputOp1] {...}
      [inputOp2] {...}      
      
     */

	{NDChoiceStatement} (LSQUARE (('linkIn' LPAREN ID RPAREN) | /*inputOperation*/ variablePath+=VariablePath LPAREN variablePath+=VariablePath RPAREN inputOperation+=InputOperation) RSQUARE
	mainProcess+=MainProcess)+;
/******************************************************************************************************************/



/********************************************InputPortStatement & OutputPortStatement*************************************************/
Port:
(inputPortStatement+=InputPortStatement | outputPortStatement+=OutputPortStatement); 


InputPortStatement:

  'inputPort' name=ID LCURLY 
  
  
 ( (location+=Location)? & 
  (protocol+=Protocol)? &   
  (oneWayOperation+=OneWayOperation)? &
  (RequestResponseOperation+=RequestResponseOperation)? &
  (redirects+=Redirects)? &
  (aggregates+=Aggregates)? &
  (intefaces+=Interfaces)? )
  
  RCURLY

  ;
  
 OutputPortStatement:

  'outputPort' name=ID LCURLY 
  
  
 ( (location+=Location)? & 
  (protocol+=Protocol)? &
  (oneWayOperation+=OneWayOperation)? &
  (RequestResponseOperation+=RequestResponseOperation)? &
  (intefaces+=Interfaces)?
  )
  RCURLY

  ; 

OneWayOperation : 
  
  {OneWayOperation} 'OneWay' COLON name=ID (LPAREN typeDefinition+=TypeDefinition RPAREN)? (COMMA children+=ID (LPAREN typeDefinition+=TypeDefinition RPAREN)?)* 
  ;

RequestResponseOperation:
  {RequestResponseOperation} 'RequestResponse' COLON name+=ID ((LPAREN typeDefinition+=TypeDefinition RPAREN) (LPAREN typeDefinition+=TypeDefinition RPAREN))? 
  ('throws' name+=ID(LPAREN typeDefinition+=TypeDefinition RPAREN))?
  (COMMA name+=ID ((LPAREN typeDefinition+=TypeDefinition RPAREN) (LPAREN typeDefinition+=TypeDefinition RPAREN))? 
  ('throws' name+=ID(LPAREN typeDefinition+=TypeDefinition RPAREN))?)*

;

TypeDefinition: 

   type+=[Type];


Location:
  'Location' COLON uri+=Uri;
  
Uri :      
  {Uri} name+=ID| {Uri} STRING;//|name=STRING; //to do...
  
Interfaces:

  'Interfaces' COLON name+=ID (COMMA name+=ID)*; 
  
Protocol:
  
  'Protocol' COLON name+=ID ProtocolConfiguration?;
  
ProtocolConfiguration:

  LCURLY 'TODO' RCURLY;  
  
Redirects:

  'Redirects' COLON  name+=ID '=>' outputPortIdentifier+=ID (COMMA name+=ID '=>' outputPortIdentifier+=ID)*; //TODO LINKING TO OutPutPortDef
  
Aggregates:

  'Aggregates' COLON name+=ID (COMMA name+=ID)*;
  
/***********************************************END InpuPortStatement**********************************************************************/    




terminal LCURLY:
	'{';

terminal RCURLY:
	'}';

terminal LSQUARE:
	'[';

terminal RSQUARE:
	']';

terminal SEMICOLON:
	';';

terminal COLON:
	':';

terminal PLUS:
	'+';

terminal VERT:
	'|';
	//terminal SESSIONDECL: 'session';
//terminal STARTS: 'starts';
//terminal ONE_WAY: 'OneWay';
//terminal REQUEST_RESPONSE: 'RequestResponse';
terminal ASSIGN:
	'=';

terminal DOT:
	'.';

terminal LPAREN:
	'(';

terminal RPAREN:
	')';

terminal COMMA:
	',';

terminal AT:
    '@';

terminal WHILE:
	'while';

terminal CHOICE:
	'++';

terminal DECREMENT:
	'--';

terminal ASTERISK:
     '*';
     
terminal QUESTION:
     '?';     

terminal DIVIDE:
	'/';

terminal POINTSTO:
	'->';

terminal DEEPCOPYLEFT:
	'<<';

terminal MINUS:
	'-';

terminal PERCENT_SIGN:
	'%';

terminal REAL:
	('0'..'9')* '.' ('0'..'9')+ (('e' | 'E') ('0'..'9')+)?;

 