grammar jolie.xtext.Jolie with org.eclipse.xtext.common.Terminals

/***************************************************************************
 *   Author: Diego Castronuovo                                             *
 *   An Xtext grammar for the programming language Jolie                   *
 ***************************************************************************/
generate jolie "http://www.xtext.org/Jolie"

Program:

((inputPortStatement+=InputPortStatement) | (outputPortStatement+=OutputPortStatement))*

/* (locations=Locations)* */ 'main' (main=Main);
/*  
Locations :
ASSIGN
 ('inputPort' name=ID LCURLY (locations=LocationDefinition) RCURLY) &
 ('outputPort' name=ID LCURLY (locations=LocationDefinition) RCURLY)

;

LocationDefinition :
 ('location' address=Address) & 'protocol' (protocol=Protocol) & (interfaces=Interfaces)*
;


Interfaces :
 'Interfaces' name=ID
;

terminal Protocol :
 'sodep' | 'soap' | 'http'
;  
 
terminal Address : 
 '"'('//') ((('a'..'z'|'A'..'Z'|'_'|'0'..'9')*'.'('a'..'z'|'A'..'Z'|'_'|'0'..'9')*)*':'('0'..'9')*) '"'

 ;
*/
Main:
	mainrocess=MainProcess;
	//Il processo principale, {...} del main
MainProcess:
	{OLSyntaxNode} LCURLY parallelStatement=ParallelStatement RCURLY;

	//Il processo generale inseribile a piacimento nel codice {...},(...)
Process:
	{Process} LCURLY children+=ParallelStatement RCURLY | LPAREN children+=ParallelStatement RPAREN;

	//Un parallel contiene una o pi sequenze separate da VERT '|'
ParallelStatement:
	{ParallelStatement} (children+=SequenceStatement (VERT children+=SequenceStatement)*);

	//Un sequence contiente uno o pi basic statemente separati da SEMICOLON ';'
SequenceStatement:
	{SequenceStatement} (children+=BasicStatement (SEMICOLON children+=BasicStatement)*);

	//Il basicStatement,  un costrutto base, ma pu anche essere un processo (questa produzione permette la ricorsione di parallel e sequence) 
BasicStatement:
	{BasicStatement} process=Process | //Questa  la regola che mi permette la ricorsione
	{BasicStatement} assignStatementOrPostIncrementDecrement=AssignStatementOrPostIncrementDecrement | {BasicStatement}
	NDChoiceStatement=NDChoiceStatement | {BasicStatement} preIncrementDecrement=PreIncrementDecrement|
	inputOp=InputOperationStatement;

AssignStatementOrPostIncrementDecrement:
	{AssignStatementOrPostIncrementDecrement} variablePath=VariablePath rightSide=RightSide;

RightSide:
	{RightSide} ASSIGN expression=Expression | {RightSide} CHOICE | {RightSide} DECREMENT | {RightSide} POINTSTO
	variablePath=VariablePath | {RightSide} DEEPCOPYLEFT variablePath=VariablePath;

PreIncrementDecrement:
	(CHOICE | DECREMENT) variablePath=VariablePath;

/*********************************************ESPRESSIONI ARITMETICHE*********************************************/
Expression:
	TerminalExpression ({Operation.left=current} op=(PLUS | MINUS | ASTERISK | DIVIDE) right=Expression)?;

TerminalExpression returns Expression:
	LPAREN Expression RPAREN | {IntLiteral} value=INT | {RealLiteral} value=REAL | {String} value=STRING | (CHOICE |
	DECREMENT) variablePath=VariablePath | variablePath=VariablePath (CHOICE | DECREMENT)?;

VariablePath:
    
	{VariablePath} ID (LSQUARE children+=Expression RSQUARE)? (((DOT (ID | 'global') (LSQUARE children+=Expression
	RSQUARE)?) | (DOT LPAREN children+=Expression RPAREN)))* | {VariablePath} 'global' (((DOT (ID | 'global') (LSQUARE
	children+=Expression RSQUARE)?) | (DOT LPAREN children+=Expression RPAREN)))*; //Global non  un un array

/******************************************************************************************************************/

/*********************************************NDChoiceStatement*********************************************/
NDChoiceStatement:
	{NDChoiceStatement} (LSQUARE ((LINKIN LPAREN ID RPAREN) | inputOperationStatement+=InputOperationStatement) RSQUARE
	mainProcess+=MainProcess)+;
/******************************************************************************************************************/

/*********************************************InputOperationStatement*********************************************/
InputOperationStatement:
	{InputOperation} ID LPAREN {VariablePath} variablePath=VariablePath RPAREN operation=Operation;

Operation:
	{Operation} (LPAREN expression=Expression RPAREN mainProcess=MainProcess)?; //line 1689 OLParser, with ? ReqResponseOperation if no ? OneWayOperation
	
	
/******************************************************************************************************************/


/********************************************InputPortStatement & OutputPortStatement*************************************************/
InputPortStatement:

  'inputPort' name=ID LCURLY 
  
  
  (location=Location & 
  protocol=Protocol &
  (oneWayOperation=OneWayOperation)? &
  (RequestResponseOperation=RequestResponseOperation)? &
  (redirects=Redirects)? &
  (aggregates=Aggregates)? &
  (intefaces=Interfaces)?)
  
  RCURLY

  ;
  
 OutputPortStatement:

  'outputPort' name=ID LCURLY 
  
  
  (location=Location? & 
  protocol=Protocol? &
  (oneWayOperation=OneWayOperation)? &
  (RequestResponseOperation=RequestResponseOperation)? &
  (intefaces=Interfaces)?)
  
  RCURLY

  ; 

OneWayOperation: 
  
  {OneWayOperation} 'OneWay' COLON children+=ID (LPAREN typeDefinition+=TypeDefinition RPAREN)? (COMMA children+=ID (LPAREN typeDefinition+=TypeDefinition RPAREN)?)* 
  ;

RequestResponseOperation:
  {RequestResponseOperation} 'RequestResponse' COLON name+=ID ((LPAREN typeDefinition+=TypeDefinition RPAREN) (LPAREN typeDefinition+=TypeDefinition RPAREN))? 
  ('throws' name+=ID(LPAREN typeDefinition+=TypeDefinition RPAREN))?
  (COMMA name+=ID ((LPAREN typeDefinition+=TypeDefinition RPAREN) (LPAREN typeDefinition+=TypeDefinition RPAREN))? 
  ('throws' name+=ID(LPAREN typeDefinition+=TypeDefinition RPAREN))?)*

;

TypeDefinition: 

   name=ID;


Location:
  'Location' COLON Uri;
  
Uri:      
  name=ID|name=STRING; //to do...
  
Interfaces:

  'Interfaces' COLON name+=ID (COMMA name+=ID)*; 
  
Protocol:
  
  'Protocol' COLON name+=ID ProtocolConfiguration?;
  
ProtocolConfiguration:

  LCURLY 'TODO' RCURLY;  
  
Redirects:

  'Redirects' COLON  name+=ID '=>' outputPortIdentifier+=ID (COMMA name+=ID '=>' outputPortIdentifier+=ID)*; //TODO LINKING TO OutPutPortDef
  
Aggregates:

  'Aggregates' COLON name+=ID (COMMA name+=ID)*;
  
/***********************************************END InpuPortStatement**********************************************************************/    



// Terminals

terminal LCURLY:
	'{';

terminal RCURLY:
	'}';

terminal LSQUARE:
	'[';

terminal RSQUARE:
	']';

terminal SEMICOLON:
	';';

terminal COLON:
	':';

terminal PLUS:
	'+';

terminal VERT:
	'|';
	//terminal SESSIONDECL: 'session';
//terminal STARTS: 'starts';
//terminal ONE_WAY: 'OneWay';
//terminal REQUEST_RESPONSE: 'RequestResponse';
terminal ASSIGN:
	'=';

terminal DOT:
	'.';

terminal LPAREN:
	'(';

terminal RPAREN:
	')';

terminal COMMA:
	',';

terminal LINKIN:
	'linkIn';

terminal WHILE:
	'while';

terminal CHOICE:
	'++';

terminal DECREMENT:
	'--';

terminal ASTERISK:
	'*';

terminal DIVIDE:
	'/';

terminal POINTSTO:
	'->';

terminal DEEPCOPYLEFT:
	'<<';

terminal MINUS:
	'-';

terminal PERCENT_SIGN:
	'%';

terminal REAL:
	('0'..'9')* '.' ('0'..'9')+ (('e' | 'E') ('0'..'9')+)?;

 